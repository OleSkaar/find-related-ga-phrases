{"version":3,"sources":["utils/Line.js","utils/Phrase.js","utils/Word.js","utils/removeInvalidLines.js","utils/PhraseContainer.js","utils/WordContainer.js","utils/parser.jsx","WordData.jsx","Wordbox.jsx","RelatedPhraseData.jsx","RelatedPrasesWindow.jsx","App.js","serviceWorker.js","index.js"],"names":["Line","phrase","count","this","parseInt","removeComma","countString","replace","Phrase","phraseString","id","relatedWords","wordObject","push","string","word","Word","relatedPhrases","phraseObject","removeInvalidLines","array","firstHeaderColumn","newArray","forEach","element","length","isCorrectLength","data","localeCompare","isNotEmpty","PhraseContainer","phrases","total","compare","a","b","wordACount","wordBCount","comparison","WordContainer","words","wordString","wordExists","include","console","log","sort","Parser","handleOnDrop","newData","line","lineObject","numberOfPhrases","includes","wordsInPhrase","split","undefined","find","addCount","numberOfWords","add","addRelatedWord","addRelatedPhrase","sortByCount","props","updateState","handleOnError","err","file","inputElem","reason","handleOnRemoveFile","onDrop","onError","addRemoveButton","onRemoveFile","Component","WordData","rowStyle","borderBottom","backgroundColor","wordId","clickedPhraseId","cellStyle","borderCollapse","padding","buttonStyle","display","fontSize","style","onClick","updateRelatedPhrases","Wordbox","tableStyle","width","margin","textAlign","isEmpty","tableRows","rowIndex","key","RelatedPhraseData","className","percentage","RelatedPhrasesWindow","totalCount","phraseIndex","toFixed","App","state","wordContainer","phraseContainer","setState","phraseId","rightSidebarStyle","textBoxStyle","maxWidth","justifyContent","flexDirection","transition","alignSelf","updateWordAndPhrases","React","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.cf98872f.chunk.js","sourcesContent":["class Line {\r\n  constructor(phrase, count) {\r\n    this.phrase = phrase;\r\n    this.count = parseInt(this.removeComma(count));\r\n  }\r\n\r\n  removeComma(countString) {\r\n    return countString.replace(\",\", \"\");\r\n  }\r\n}\r\n\r\nexport default Line;\r\n","class Phrase {\r\n  constructor(phraseString, count, id) {\r\n    this.phrase = phraseString;\r\n    this.count = count;\r\n    this.id = id;\r\n    this.relatedWords = [];\r\n  }\r\n\r\n  get words() {\r\n    let string = \"\";\r\n    for (const word of this.relatedWords) {\r\n      string += ` ${word}, `;\r\n    }\r\n\r\n    return string;\r\n  }\r\n\r\n  addRelatedWord(wordObject) {\r\n    //console.log(`Adding ${wordObject.word}`)\r\n    //if (!this.relatedWords.includes(wordObject)) this.relatedWords.push(wordObject)\r\n    this.relatedWords.push(wordObject);\r\n    //console.log(this)\r\n  }\r\n}\r\n\r\nexport default Phrase;\r\n","class Word {\r\n  constructor(word, count, id) {\r\n    this.word = word;\r\n    this.count = count;\r\n    this.id = id;\r\n    this.relatedPhrases = [];\r\n  }\r\n\r\n  addCount(count) {\r\n    this.count += count;\r\n  }\r\n\r\n  addRelatedPhrase(phraseObject) {\r\n    this.relatedPhrases.push(phraseObject);\r\n  }\r\n}\r\n\r\nexport default Word;\r\n","export const removeInvalidLines = (array, firstHeaderColumn) => {\r\n  const isCorrectLength = (array) => array.length > 2;\r\n  const isNotHeader = (string) => string.localeCompare(firstHeaderColumn);\r\n  const isNotEmpty = (string) => string.length > 0;\r\n\r\n  const newArray = [];\r\n\r\n  array.forEach((element) => {\r\n    if (\r\n      isCorrectLength(element.data) &&\r\n      isNotHeader(element.data[0]) &&\r\n      isNotEmpty(element.data[0])\r\n    )\r\n      newArray.push(element);\r\n  });\r\n\r\n  return newArray;\r\n};\r\n","class PhraseContainer {\r\n  constructor() {\r\n    this.phrases = [];\r\n  }\r\n\r\n  add(phraseObject) {\r\n    this.phrases.push(phraseObject);\r\n  }\r\n\r\n  get totalCount() {\r\n    let total = 0;\r\n    for (const phrase of this.phrases) {\r\n      total += phrase.count;\r\n    }\r\n\r\n    return total;\r\n  }\r\n\r\n  get numberOfPhrases() {\r\n    return this.phrases.length;\r\n  }\r\n\r\n  get isEmpty() {\r\n    return this.phrases.length === 0;\r\n  }\r\n}\r\n\r\nexport default PhraseContainer;\r\n","class WordContainer {\r\n  constructor() {\r\n    this.words = [];\r\n  }\r\n\r\n  get numberOfWords() {\r\n    return this.words.length;\r\n  }\r\n\r\n  get isEmpty() {\r\n    return this.words.length === 0;\r\n  }\r\n\r\n  include(wordString) {\r\n    let wordExists = false;\r\n    for (const word of this.words) {\r\n      if (word.word === wordString) {\r\n        wordExists = true;\r\n        break;\r\n      }\r\n    }\r\n    return wordExists;\r\n  }\r\n\r\n  find(wordString) {\r\n    if (this.include(wordString)) {\r\n      for (const word of this.words) {\r\n        if (word.word === wordString) {\r\n          return word;\r\n        }\r\n      }\r\n    } else {\r\n      console.log(`Cannot find ${wordString}`);\r\n    }\r\n  }\r\n\r\n  add(wordObject) {\r\n    this.words.push(wordObject);\r\n  }\r\n\r\n  sortByCount() {\r\n    this.words.sort(compare);\r\n  }\r\n}\r\n\r\nfunction compare(a, b) {\r\n  const wordACount = a.count;\r\n  const wordBCount = b.count;\r\n\r\n  let comparison = 0;\r\n\r\n  if (wordACount > wordBCount) {\r\n    comparison = -1;\r\n  } else if (wordACount < wordBCount) {\r\n    comparison = 1;\r\n  }\r\n\r\n  return comparison;\r\n}\r\n\r\nexport default WordContainer;\r\n","import React, { Component } from \"react\";\r\nimport Line from \"./Line.js\";\r\nimport Phrase from \"./Phrase.js\";\r\nimport Word from \"./Word.js\";\r\nimport { removeInvalidLines } from \"./removeInvalidLines.js\";\r\nimport PhraseContainer from \"./PhraseContainer.js\";\r\nimport WordContainer from \"./WordContainer.js\";\r\n\r\nimport { CSVReader } from \"react-papaparse\";\r\n\r\nconst firstColumn = \"Search Term\";\r\nconst space = \" \";\r\n\r\nexport class Parser extends Component {\r\n  handleOnDrop = (data) => {\r\n    const words = new WordContainer();\r\n    const phrases = new PhraseContainer();\r\n    const newData = removeInvalidLines(data, firstColumn);\r\n\r\n    for (const line of newData) {\r\n      const lineObject = new Line(line.data[0], line.data[1]);\r\n      const phrase = lineObject.phrase;\r\n      const count = lineObject.count;\r\n\r\n      const phraseObject = new Phrase(\r\n        phrase,\r\n        count,\r\n        phrases.numberOfPhrases + 1\r\n      );\r\n\r\n      if (phrase.includes(space)) {\r\n        const wordsInPhrase = phrase.split(space);\r\n\r\n        for (const wordString of wordsInPhrase) {\r\n          let wordObject = undefined;\r\n\r\n          if (words.include(wordString)) {\r\n            wordObject = words.find(wordString);\r\n            wordObject.addCount(count);\r\n          } else {\r\n            wordObject = new Word(wordString, count, words.numberOfWords + 1);\r\n            words.add(wordObject);\r\n          }\r\n\r\n          phraseObject.addRelatedWord(wordObject);\r\n          wordObject.addRelatedPhrase(phraseObject);\r\n        }\r\n      } else {\r\n        let wordObject = undefined;\r\n\r\n        if (words.include(phrase)) {\r\n          wordObject = words.find(phrase);\r\n          wordObject.addCount(count);\r\n          wordObject.addRelatedPhrase(phraseObject);\r\n        } else {\r\n          wordObject = new Word(phrase, count, words.numberOfWords + 1);\r\n          wordObject.addRelatedPhrase(phraseObject);\r\n          words.add(wordObject);\r\n        }\r\n      }\r\n      phrases.add(phraseObject);\r\n    }\r\n    words.sortByCount();\r\n    this.props.updateState(words, phrases);\r\n  };\r\n\r\n  handleOnError = (err, file, inputElem, reason) => {\r\n    console.log(err);\r\n  };\r\n\r\n  handleOnRemoveFile = (data) => {\r\n    console.log(\"---------------------------\");\r\n    console.log(data);\r\n    console.log(\"---------------------------\");\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <CSVReader\r\n        onDrop={this.handleOnDrop}\r\n        onError={this.handleOnError}\r\n        addRemoveButton\r\n        onRemoveFile={this.handleOnRemoveFile}\r\n      >\r\n        <span>Drop CSV file here or click to upload.</span>\r\n      </CSVReader>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\n\r\nfunction WordData(props) {\r\n  const isClicked = props.wordId === props.clickedPhraseId;\r\n\r\n  const rowStyle = {\r\n    borderBottom: \"1px solid gainsboro\",\r\n    backgroundColor: isClicked ? \"#DBE0F0\" : \"white\",\r\n  };\r\n\r\n  const cellStyle = {\r\n    borderCollapse: \"collapse\",\r\n    padding: \"5px\",\r\n  };\r\n\r\n  const buttonStyle = {\r\n    display: props.relatedPhrases.length > 1 ? \"inherit\" : \"none\",\r\n    fontSize: \"1.1em\",\r\n  };\r\n\r\n  return (\r\n    <tr style={rowStyle}>\r\n      <td style={cellStyle}>{props.wordString}</td>\r\n      <td style={cellStyle}>{props.count}</td>\r\n      <td style={cellStyle}>{props.relatedPhrases.length}</td>\r\n      <td style={cellStyle}>\r\n        <button\r\n          style={buttonStyle}\r\n          onClick={() =>\r\n            props.updateRelatedPhrases(props.relatedPhrases, props.wordId)\r\n          }\r\n        >\r\n          🡲\r\n        </button>\r\n      </td>\r\n    </tr>\r\n  );\r\n}\r\n\r\nexport default WordData;\r\n","import React from \"react\";\r\nimport WordData from \"./WordData.jsx\";\r\n\r\nfunction Wordbox(props) {\r\n  const tableStyle = {\r\n    width: \"100%\",\r\n    margin: \"auto\",\r\n    borderCollapse: \"collapse\",\r\n    textAlign: \"left\",\r\n    display: props.isEmpty ? \"none\" : \"table\",\r\n  };\r\n\r\n  const tableRows = [];\r\n  let rowIndex = 0;\r\n  for (const word of props.words) {\r\n    tableRows.push(\r\n      <WordData\r\n        wordId={word.id}\r\n        key={rowIndex}\r\n        wordString={word.word}\r\n        count={word.count}\r\n        relatedPhrases={word.relatedPhrases}\r\n        clickedPhraseId={props.clickedPhraseId}\r\n        updateRelatedPhrases={props.updateRelatedPhrases}\r\n      />\r\n    );\r\n    rowIndex++;\r\n  }\r\n\r\n  return (\r\n    <table style={tableStyle}>\r\n      <thead>\r\n        <tr>\r\n          <th>\r\n            <h2>Search phrase</h2>\r\n          </th>\r\n          <th>\r\n            <h2>Unique searches</h2>\r\n          </th>\r\n          <th>\r\n            <h2>Related Phrases</h2>\r\n          </th>\r\n        </tr>\r\n      </thead>\r\n      <tbody>{tableRows}</tbody>\r\n    </table>\r\n  );\r\n}\r\n\r\nexport default Wordbox;\r\n","import React from 'react'\r\n\r\nfunction RelatedPhraseData(props) {\r\n    \r\n    return (\r\n        <tr className='tableRow'>\r\n            <td>{props.phrase}</td>\r\n            <td>{props.count}</td>\r\n            <td>{props.percentage}</td>\r\n        </tr>\r\n    )\r\n}\r\n\r\nexport default RelatedPhraseData;","import React from 'react'\r\nimport RelatedPhraseData from './RelatedPhraseData.jsx'\r\n\r\nfunction RelatedPhrasesWindow(props) {\r\n    let totalCount = 0;\r\n    for (const phrase of props.relatedPhrases) {\r\n        totalCount += phrase.count\r\n    }\r\n\r\n    const relatedPhrases = []\r\n    let phraseIndex = 0;\r\n    for (const phrase of props.relatedPhrases) {\r\n        const percentage = ((phrase.count / totalCount) * 100).toFixed(1)\r\n        relatedPhrases.push(\r\n            <RelatedPhraseData\r\n                key={phraseIndex}\r\n                phrase={phrase.phrase}\r\n                count={phrase.count}\r\n                percentage={`${percentage} %`}\r\n            />\r\n        )\r\n        phraseIndex++\r\n    }\r\n\r\n    return (\r\n        <div>\r\n            <table className='relatedPhraseWindow'>\r\n                <tbody>\r\n                    <tr>\r\n                        <th><h3>Related phrases</h3></th>\r\n                        <th><h3>Unique searches</h3></th>\r\n                        <th><h3>% of total</h3></th>\r\n                    </tr>\r\n                    {relatedPhrases}\r\n                    <tr>\r\n                        <td><strong>Total:</strong></td>\r\n                        <td><strong>{totalCount}</strong></td>\r\n                        <td><strong>100%</strong></td>\r\n                    </tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default RelatedPhrasesWindow;","import React from \"react\";\r\nimport \"./App.css\";\r\nimport { Parser } from \"./utils/parser.jsx\";\r\nimport PhraseContainer from \"./utils/PhraseContainer.js\";\r\nimport WordContainer from \"./utils/WordContainer.js\";\r\nimport Wordbox from \"./Wordbox.jsx\";\r\nimport RelatedPhrasesWindow from \"./RelatedPrasesWindow.jsx\";\r\n\r\nclass App extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      wordContainer: new WordContainer(),\r\n      phraseContainer: new PhraseContainer(),\r\n      isEmpty: true,\r\n      relatedPhrases: [],\r\n      clickedPhraseId: undefined,\r\n    };\r\n  }\r\n\r\n  updateWordAndPhrases(words, phrases) {\r\n    this.setState({\r\n      wordContainer: words,\r\n      phraseContainer: phrases,\r\n      isEmpty: words.isEmpty && phrases.isEmpty,\r\n    });\r\n  }\r\n\r\n  updateRelatedPhrases(relatedPhrases, phraseId) {\r\n    this.setState({\r\n      relatedPhrases: relatedPhrases,\r\n      clickedPhraseId: phraseId,\r\n    });\r\n  }\r\n\r\n  render() {\r\n    const mainContentStyle = {\r\n      width: \"40%\",\r\n      display: \"flex\",\r\n      alignSelf: \"center\",\r\n    };\r\n\r\n    const rightSidebarStyle = {\r\n      display: this.state.relatedPhrases.length > 0 ? \"flex\" : \"none\",\r\n    };\r\n\r\n    const flexboxContainer = {\r\n      maxWidth: \"100vw\",\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      flexDirection: \"row\",\r\n      transition: \"all 1s ease\",\r\n    };\r\n\r\n    const textBoxStyle = {\r\n      maxWidth: \"40%\",\r\n      margin: \"auto\",\r\n    };\r\n\r\n    return (\r\n      <div className=\"App\">\r\n        <header className=\"App-header\">\r\n          <h1>🔍 Find related phrases</h1>\r\n        </header>\r\n        <div style={textBoxStyle}>\r\n          <p>\r\n            This is a tool to help analyze and organize site search data from\r\n            Google Analytics.\r\n          </p>\r\n          <p>\r\n            To use it, navigate to Behavior {\">\"} Site Search {\">\"} Search\r\n            Terms, choose the time span you want data for, and choose Export{\" \"}\r\n            {\">\"} CSV.\r\n          </p>\r\n          <p>\r\n            Then, upload the CSV with drag and drop or browse, and it will\r\n            connect all phrases that contain the same word.\r\n          </p>\r\n          <p>\r\n            For instance, if 10 users have searched for 'sleeping bag', and 5\r\n            users have searched for 'red sleeping bag', the phraseContainer\r\n            'sleeping bag' will now have 15 unique searches, and 'red sleeping\r\n            bag' will be marked as a related phrase to 'sleeping bag'.\r\n          </p>\r\n        </div>\r\n        <div style={flexboxContainer}>\r\n          <div style={mainContentStyle}>\r\n            <Wordbox\r\n              isEmpty={this.state.isEmpty}\r\n              words={this.state.wordContainer.words}\r\n              phrases={this.state.phraseContainer.phrases}\r\n              clickedPhraseId={this.state.clickedPhraseId}\r\n              updateRelatedPhrases={(relatedPhrases, phraseId) =>\r\n                this.updateRelatedPhrases(relatedPhrases, phraseId)\r\n              }\r\n            />\r\n          </div>\r\n          <div style={rightSidebarStyle}>\r\n            <RelatedPhrasesWindow relatedPhrases={this.state.relatedPhrases} />\r\n          </div>\r\n        </div>\r\n        <div style={textBoxStyle}>\r\n          <Parser\r\n            onDrop={this.handleOnDrop}\r\n            onError={this.handleOnError}\r\n            addRemoveButton\r\n            onRemoveFile={this.handleOnRemoveFile}\r\n            updateState={(words, phrases) =>\r\n              this.updateWordAndPhrases(words, phrases)\r\n            }\r\n          >\r\n            <span>Click to upload.</span>\r\n          </Parser>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}